<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Interview Cheat Sheet</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.20/babel.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
            --border-color: #ddd;
            --highlight-color: #f8f9fa;
            --accent-color: #e74c3c;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        body {
            background-color: var(--light-color);
            color: var(--dark-color);
            line-height: 1.6;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            width: 280px;
            background-color: var(--dark-color);
            color: white;
            padding: 20px 0;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 10;
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-header h1 {
            font-size: 1.4rem;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .nav-list {
            list-style: none;
            padding: 0;
        }

        .nav-item {
            padding: 10px 20px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: background-color 0.2s;
        }

        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background-color: rgba(255, 255, 255, 0.1);
            border-left-color: var(--secondary-color);
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        .nav-item span {
            font-size: 0.9rem;
        }

        .sub-nav {
            padding-left: 20px;
            font-size: 0.85rem;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .sub-nav.open {
            max-height: 500px;
        }

        .sub-nav-item {
            padding: 8px 10px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .sub-nav-item:hover, .sub-nav-item.active {
            opacity: 1;
        }

        .content {
            flex: 1;
            margin-left: 280px;
            padding: 30px;
        }

        .section {
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            margin-bottom: 40px;
        }

        .section.active {
            display: block;
            opacity: 1;
        }

        .section-header {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary-color);
        }

        .section-header h2 {
            font-size: 1.8rem;
            color: var(--dark-color);
        }

        .summary-box {
            background-color: white;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .summary-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .qa-item {
            background-color: white;
            border-radius: 5px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .question {
            padding: 15px 20px;
            font-weight: 600;
            cursor: pointer;
            background-color: var(--highlight-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 3px solid var(--primary-color);
        }

        .question:hover {
            background-color: #f0f0f0;
        }

        .question i {
            transition: transform 0.3s ease;
        }

        .question.open i {
            transform: rotate(180deg);
        }

        .answer {
            padding: 0 20px;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .answer.open {
            padding: 15px 20px;
            max-height: 1000px;
        }

        .answer p {
            margin-bottom: 10px;
        }

        .answer ul, .answer ol {
            padding-left: 20px;
            margin-bottom: 10px;
        }

        .answer li {
            margin-bottom: 5px;
        }

        .search-container {
            padding: 10px 20px 20px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 8px 15px;
            border-radius: 20px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.9rem;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-input:focus {
            outline: none;
            background-color: rgba(255, 255, 255, 0.2);
        }

        .search-icon {
            position: absolute;
            right: 30px;
            top: 18px;
            color: rgba(255, 255, 255, 0.5);
        }

        .difficulty {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            margin-left: 10px;
            text-transform: uppercase;
        }

        .easy {
            background-color: #2ecc71;
            color: white;
        }

        .medium {
            background-color: #f39c12;
            color: white;
        }

        .hard {
            background-color: #e74c3c;
            color: white;
        }

        code {
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .toggle-sidebar {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: var(--dark-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 20;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .content {
                margin-left: 0;
            }
            
            .toggle-sidebar {
                display: block;
            }
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 20px;
            right: 20px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
        }

        .search-result-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            color: var(--dark-color);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background-color: var(--highlight-color);
        }

        .search-result-item i {
            margin-right: 8px;
            color: var(--primary-color);
        }

        .search-result-highlight {
            background-color: rgba(52, 152, 219, 0.2);
            padding: 2px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const App = () => {
            const [activeSection, setActiveSection] = React.useState('math-calculus');
            const [openSections, setOpenSections] = React.useState({
                'math': true,
                'cs': false,
                'ml-fund': false,
                'ml-methods': false
            });
            const [openQAs, setOpenQAs] = React.useState({});
            const [sidebarOpen, setSidebarOpen] = React.useState(false);
            const [searchTerm, setSearchTerm] = React.useState('');
            const [searchResults, setSearchResults] = React.useState([]);
            const [showSearchResults, setShowSearchResults] = React.useState(false);

            const toggleSection = (section) => {
                setOpenSections({
                    ...openSections,
                    [section]: !openSections[section]
                });
            };

            const toggleQA = (id) => {
                setOpenQAs({
                    ...openQAs,
                    [id]: !openQAs[id]
                });
            };

            const toggleSidebar = () => {
                setSidebarOpen(!sidebarOpen);
            };

            const handleSearch = (e) => {
                const query = e.target.value;
                setSearchTerm(query);
                
                if (!query.trim()) {
                    setSearchResults([]);
                    setShowSearchResults(false);
                    return;
                }

                const results = [];
                const lowerQuery = query.toLowerCase();

                // Helper function to create search result
                const addResult = (type, section, question, answer = null) => {
                    results.push({
                        type,
                        section,
                        question,
                        answer,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                };

                // Search through all sections
                Object.entries(openQAs).forEach(([qaId, isOpen]) => {
                    const qaElement = document.querySelector(`[data-qa-id="${qaId}"]`);
                    if (!qaElement) return;

                    const questionText = qaElement.querySelector('.question').textContent;
                    const answerText = qaElement.querySelector('.answer').textContent;

                    if (questionText.toLowerCase().includes(lowerQuery)) {
                        addResult('question', qaId.split('-')[0], questionText);
                    }
                    if (answerText.toLowerCase().includes(lowerQuery)) {
                        addResult('answer', qaId.split('-')[0], questionText, answerText);
                    }
                });

                setSearchResults(results);
                setShowSearchResults(results.length > 0);
            };

            const handleSearchResultClick = (result) => {
                // Find the section for this result
                const sectionKey = result.section;
                const qaId = `${sectionKey}-${result.type === 'question' ? result.question : result.answer}`;
                
                // Open the relevant section
                setOpenSections(prev => ({
                    ...prev,
                    [sectionKey]: true
                }));

                // Open the specific QA item
                setOpenQAs(prev => ({
                    ...prev,
                    [qaId]: true
                }));

                // Clear search
                setSearchTerm('');
                setShowSearchResults(false);

                // Scroll to the element
                setTimeout(() => {
                    const element = document.querySelector(`[data-qa-id="${qaId}"]`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        element.classList.add('search-result-highlight');
                        setTimeout(() => element.classList.remove('search-result-highlight'), 2000);
                    }
                }, 100);
            };

            // Content sections
            return (
                <div className="container">
                    <button className="toggle-sidebar" onClick={toggleSidebar}>
                        <i className="fas fa-bars"></i>
                    </button>
                    
                    <div className={`sidebar ${sidebarOpen ? 'open' : ''}`}>
                        <div className="sidebar-header">
                            <h1>ML Interview Cheat Sheet</h1>
                            <p>Based on Chip Huyen's ML Interview Book</p>
                        </div>
                        
                        <div className="search-container">
                            <input 
                                type="text" 
                                className="search-input"
                                placeholder="Search questions..."
                                value={searchTerm}
                                onChange={handleSearch}
                                onFocus={() => setShowSearchResults(searchResults.length > 0)}
                            />
                            <i className="fas fa-search search-icon"></i>
                            
                            {showSearchResults && (
                                <div className="search-results">
                                    {searchResults.map(result => (
                                        <div 
                                            key={result.id}
                                            className="search-result-item"
                                            onClick={() => handleSearchResultClick(result)}
                                        >
                                            {result.type === 'question' ? (
                                                <><i className="fas fa-question-circle"></i> {result.question}</>
                                            ) : (
                                                <><i className="fas fa-comment-dots"></i> Answer containing: "{searchTerm}" in question "{result.question}"</>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                        
                        <ul className="nav-list">
                            <li className={`nav-item ${openSections['math'] ? 'active' : ''}`} onClick={() => toggleSection('math')}>
                                <i className="fas fa-square-root-alt"></i>
                                <span>Mathematics Foundations</span>
                                <i className={`fas fa-chevron-${openSections['math'] ? 'down' : 'right'}`} style={{float: 'right'}}></i>
                            </li>
                            <ul className={`sub-nav ${openSections['math'] ? 'open' : ''}`}>
                                <li className={`sub-nav-item ${activeSection === 'math-calculus' ? 'active' : ''}`} onClick={() => setActiveSection('math-calculus')}>
                                    Calculus & Optimization
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'math-probability' ? 'active' : ''}`} onClick={() => setActiveSection('math-probability')}>
                                    Probability & Statistics
                                </li>
                            </ul>
                            
                            <li className={`nav-item ${openSections['cs'] ? 'active' : ''}`} onClick={() => toggleSection('cs')}>
                                <i className="fas fa-laptop-code"></i>
                                <span>CS Fundamentals</span>
                                <i className={`fas fa-chevron-${openSections['cs'] ? 'down' : 'right'}`} style={{float: 'right'}}></i>
                            </li>
                            <ul className={`sub-nav ${openSections['cs'] ? 'open' : ''}`}>
                                <li className={`sub-nav-item ${activeSection === 'cs-algorithms' ? 'active' : ''}`} onClick={() => setActiveSection('cs-algorithms')}>
                                    Algorithms
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'cs-complexity' ? 'active' : ''}`} onClick={() => setActiveSection('cs-complexity')}>
                                    Complexity & Numerical Analysis
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'cs-data-structures' ? 'active' : ''}`} onClick={() => setActiveSection('cs-data-structures')}>
                                    Data Structures & Handling
                                </li>
                            </ul>
                            
                            <li className={`nav-item ${openSections['ml-fund'] ? 'active' : ''}`} onClick={() => toggleSection('ml-fund')}>
                                <i className="fas fa-brain"></i>
                                <span>ML Fundamentals</span>
                                <i className={`fas fa-chevron-${openSections['ml-fund'] ? 'down' : 'right'}`} style={{float: 'right'}}></i>
                            </li>
                            <ul className={`sub-nav ${openSections['ml-fund'] ? 'open' : ''}`}>
                                <li className={`sub-nav-item ${activeSection === 'ml-basics' ? 'active' : ''}`} onClick={() => setActiveSection('ml-basics')}>
                                    ML Basics
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'ml-sampling' ? 'active' : ''}`} onClick={() => setActiveSection('ml-sampling')}>
                                    Sampling & Training Data
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'ml-evaluation' ? 'active' : ''}`} onClick={() => setActiveSection('ml-evaluation')}>
                                    Metrics & Evaluation
                                </li>
                            </ul>
                            
                            <li className={`nav-item ${openSections['ml-methods'] ? 'active' : ''}`} onClick={() => toggleSection('ml-methods')}>
                                <i className="fas fa-cogs"></i>
                                <span>ML Methods</span>
                                <i className={`fas fa-chevron-${openSections['ml-methods'] ? 'down' : 'right'}`} style={{float: 'right'}}></i>
                            </li>
                            <ul className={`sub-nav ${openSections['ml-methods'] ? 'open' : ''}`}>
                                <li className={`sub-nav-item ${activeSection === 'ml-classical' ? 'active' : ''}`} onClick={() => setActiveSection('ml-classical')}>
                                    Classical ML
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'ml-nlp' ? 'active' : ''}`} onClick={() => setActiveSection('ml-nlp')}>
                                    NLP
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'ml-cv' ? 'active' : ''}`} onClick={() => setActiveSection('ml-cv')}>
                                    Computer Vision
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'ml-rl' ? 'active' : ''}`} onClick={() => setActiveSection('ml-rl')}>
                                    Reinforcement Learning
                                </li>
                                <li className={`sub-nav-item ${activeSection === 'ml-training' ? 'active' : ''}`} onClick={() => setActiveSection('ml-training')}>
                                    Training Neural Networks
                                </li>
                            </ul>
                        </ul>
                    </div>
                    
                    <div className="content">
                        {/* Mathematics - Calculus & Optimization */}
                        <section className={`section ${activeSection === 'math-calculus' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Calculus & Convex Optimization</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Calculus and convex optimization are fundamental to understanding how machine learning algorithms work, 
                                    especially for gradient-based methods. Key topics include differentiability, convexity, optimization techniques,
                                    and their applications in machine learning algorithms.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="calculus-1">
                                    <div className={`question ${openQAs['calculus-1'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-1')}>
                                        What does it mean when a function is differentiable?
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-1'] ? 'open' : ''}`}>
                                        <p>
                                            A function is differentiable at a point if it has a derivative at that point. Geometrically, 
                                            this means the function has a unique tangent line at that point and the function's graph has no 
                                            "corners" or "kinks" there.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="calculus-2">
                                    <div className={`question ${openQAs['calculus-2'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-2')}>
                                        Example of when a function doesn't have a derivative at a point
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-2'] ? 'open' : ''}`}>
                                        <p>
                                            The absolute value function f(x) = |x| is not differentiable at x = 0 because it has a sharp corner at that point.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="calculus-3">
                                    <div className={`question ${openQAs['calculus-3'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-3')}>
                                        Non-differentiable functions in ML and backpropagation
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-3'] ? 'open' : ''}`}>
                                        <p>
                                            ReLU (f(x) = max(0, x)) is a common non-differentiable function in ML, with no derivative at x = 0. 
                                            During backpropagation, we use subgradients or define a convention (like setting the gradient to 0 or 1 at x = 0) 
                                            to handle these points.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="calculus-4">
                                    <div className={`question ${openQAs['calculus-4'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-4')}>
                                        What makes a function convex or concave?
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-4'] ? 'open' : ''}`}>
                                        <p>
                                            A function is convex if a line segment connecting any two points on the graph lies above or on the graph. 
                                            Mathematically, f(tx + (1-t)y) ≤ tf(x) + (1-t)f(y) for all x, y and t ∈ [0,1]. 
                                            A function is concave if the negative of the function is convex.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="calculus-5">
                                    <div className={`question ${openQAs['calculus-5'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-5')}>
                                        Why is convexity desirable in optimization?
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-5'] ? 'open' : ''}`}>
                                        <p>
                                            Convex functions have a global minimum (no local minima), making optimization much easier and 
                                            guaranteeing convergence to the global solution with gradient-based methods.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="calculus-6">
                                    <div className={`question ${openQAs['calculus-6'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-6')}>
                                        First-order vs. second-order optimization methods
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-6'] ? 'open' : ''}`}>
                                        <p>
                                            First-order methods use gradients (first derivatives) to optimize functions. Examples include gradient descent and SGD. 
                                            Second-order methods use both gradients and Hessians (second derivatives), like Newton's method. 
                                            Second-order methods can converge faster but are more computationally expensive.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="calculus-7">
                                    <div className={`question ${openQAs['calculus-7'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-7')}>
                                        Using Hessian matrix to test critical points
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-7'] ? 'open' : ''}`}>
                                        <p>
                                            For a critical point (where gradient = 0):
                                        </p>
                                        <ul>
                                            <li>If the Hessian is positive definite, it's a local minimum</li>
                                            <li>If the Hessian is negative definite, it's a local maximum</li>
                                            <li>If the Hessian has both positive and negative eigenvalues, it's a saddle point</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="calculus-8">
                                    <div className={`question ${openQAs['calculus-8'] ? 'open' : ''}`} onClick={() => toggleQA('calculus-8')}>
                                        Jensen's inequality
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['calculus-8'] ? 'open' : ''}`}>
                                        <p>
                                            For a convex function f and a random variable X: f(E[X]) ≤ E[f(X)]. For a concave function, 
                                            the inequality is reversed. This is fundamental to many ML concepts, including the EM algorithm and variational inference.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* Mathematics - Probability & Statistics */}
                        <section className={`section ${activeSection === 'math-probability' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Probability & Statistics</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Core probability and statistical concepts essential for ML. This includes probability distributions,
                                    independence, statistical tests, experimental design, and data analysis methods.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="prob-1">
                                    <div className={`question ${openQAs['prob-1'] ? 'open' : ''}`} onClick={() => toggleQA('prob-1')}>
                                        PDF values greater than 1
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-1'] ? 'open' : ''}`}>
                                        <p>
                                            Yes, probability density function (PDF) values can be greater than 1. This is because:
                                        </p>
                                        <ul>
                                            <li>PDF values represent density, not probability</li>
                                            <li>Only the area under the curve over an interval represents probability</li>
                                            <li>For a very narrow distribution, the peak density can exceed 1 to ensure total area equals 1</li>
                                            <li>Example: Uniform distribution over [0, 0.5] has PDF value of 2 everywhere in its range</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="prob-2">
                                    <div className={`question ${openQAs['prob-2'] ? 'open' : ''}`} onClick={() => toggleQA('prob-2')}>
                                        Normal distribution assumption
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-2'] ? 'open' : ''}`}>
                                        <p>
                                            Assuming unknown variables follow normal distributions is common because:
                                        </p>
                                        <ul>
                                            <li>Central Limit Theorem: Sums of many independent variables tend toward normal distribution</li>
                                            <li>Maximum entropy: Normal distribution has maximum entropy among distributions with same variance</li>
                                            <li>Mathematical tractability: Normal distributions have convenient mathematical properties</li>
                                            <li>Often a reasonable approximation for natural phenomena</li>
                                            <li>Many statistical methods assume normality</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="prob-3">
                                    <div className={`question ${openQAs['prob-3'] ? 'open' : ''}`} onClick={() => toggleQA('prob-3')}>
                                        Rare disease testing
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-3'] ? 'open' : ''}`}>
                                        <p>
                                            For a disease with prevalence 0.1%, test sensitivity 99% and specificity 99%:
                                        </p>
                                        <p>
                                            Given a positive test, the probability person has the disease (using Bayes' rule):
                                        </p>
                                        <p>
                                            P(Disease|Positive) = P(Positive|Disease) × P(Disease) / P(Positive)
                                        </p>
                                        <p>
                                            P(Positive) = P(Positive|Disease)P(Disease) + P(Positive|No Disease)P(No Disease)
                                            = 0.99 × 0.001 + 0.01 × 0.999 = 0.00099 + 0.00999 = 0.01098
                                        </p>
                                        <p>
                                            P(Disease|Positive) = 0.99 × 0.001 / 0.01098 ≈ 0.09 or 9%
                                        </p>
                                        <p>
                                            This demonstrates the base rate fallacy - even with a "99% accurate" test, a positive result only indicates a 9% chance of disease when the disease is rare.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="prob-4">
                                    <div className={`question ${openQAs['prob-4'] ? 'open' : ''}`} onClick={() => toggleQA('prob-4')}>
                                        Mean vs. median usage
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-4'] ? 'open' : ''}`}>
                                        <p>
                                            Use median instead of mean when:
                                        </p>
                                        <ul>
                                            <li>Data has significant outliers (median is robust to outliers)</li>
                                            <li>Distribution is highly skewed (e.g., income distributions)</li>
                                            <li>Dealing with ordinal data where arithmetic operations aren't meaningful</li>
                                            <li>Reporting "typical" values where outliers would distort perception</li>
                                        </ul>
                                        <p>
                                            Use mean instead of median when:
                                        </p>
                                        <ul>
                                            <li>Distribution is symmetric or approximately normal</li>
                                            <li>Building statistical models that use expected values</li>
                                            <li>Working with continuous data where arithmetic operations are meaningful</li>
                                            <li>When total or sum matters (mean × count = sum)</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="prob-5">
                                    <div className={`question ${openQAs['prob-5'] ? 'open' : ''}`} onClick={() => toggleQA('prob-5')}>
                                        A/B testing pros and cons
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-5'] ? 'open' : ''}`}>
                                        <p>
                                            Pros of A/B testing:
                                        </p>
                                        <ul>
                                            <li>Provides direct causal evidence of impact</li>
                                            <li>Relatively simple to set up and analyze</li>
                                            <li>Reduces reliance on intuition or opinions</li>
                                            <li>Allows incremental improvements with measurable results</li>
                                            <li>Can deliver concrete ROI metrics</li>
                                        </ul>
                                        <p>
                                            Cons of A/B testing:
                                        </p>
                                        <ul>
                                            <li>Requires sufficient traffic/samples for statistical significance</li>
                                            <li>May take time to collect enough data</li>
                                            <li>Only tests a single variable at a time (without factorial design)</li>
                                            <li>Doesn't explain why one version performed better</li>
                                            <li>Can lead to local optimization instead of global improvements</li>
                                            <li>May miss interaction effects between variables</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="prob-6">
                                    <div className={`question ${openQAs['prob-6'] ? 'open' : ''}`} onClick={() => toggleQA('prob-6')}>
                                        Doubling ads impact
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-6'] ? 'open' : ''}`}>
                                        <p>
                                            Doubling the number of ads shown may not double revenue because:
                                        </p>
                                        <ul>
                                            <li>User experience degradation could lead to reduced engagement</li>
                                            <li>Users might spend less time on the platform, reducing total ad views</li>
                                            <li>Ad effectiveness may decrease (banner blindness, attention fatigue)</li>
                                            <li>Click-through rates might drop due to increased ad load</li>
                                            <li>Long-term user retention could be negatively impacted</li>
                                        </ul>
                                        <p>
                                            To find out the actual impact:
                                        </p>
                                        <ol>
                                            <li>Run a controlled A/B test with a small percentage of users</li>
                                            <li>Measure both immediate revenue changes and user engagement metrics</li>
                                            <li>Track longer-term impacts on retention and platform usage</li>
                                            <li>Calculate the elasticity of revenue with respect to ad load</li>
                                            <li>Consider a graduated approach if results are positive but non-linear</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="prob-7">
                                    <div className={`question ${openQAs['prob-7'] ? 'open' : ''}`} onClick={() => toggleQA('prob-7')}>
                                        Statistical significance vs. p-values
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-7'] ? 'open' : ''}`}>
                                        <p>
                                            Assessing statistical significance:
                                        </p>
                                        <ul>
                                            <li>Formulate a null hypothesis (e.g., no effect/relationship exists)</li>
                                            <li>Calculate test statistic from observed data</li>
                                            <li>Determine p-value: probability of observing results at least as extreme under null hypothesis</li>
                                            <li>If p-value &lt; significance level (typically 0.05), reject null hypothesis</li>
                                        </ul>
                                        <p>
                                            P-values are uniformly distributed under the null hypothesis (when null is true). This means:
                                        </p>
                                        <ul>
                                            <li>If null hypothesis is true, p-values are equally likely to be any value between 0 and 1</li>
                                            <li>5% of tests will show p &lt; 0.05 by random chance (Type I error)</li>
                                            <li>There's no clustering or pattern to p-values under the null</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="prob-8">
                                    <div className={`question ${openQAs['prob-8'] ? 'open' : ''}`} onClick={() => toggleQA('prob-8')}>
                                        Independence testing between variables
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['prob-8'] ? 'open' : ''}`}>
                                        <p>
                                            For categorical variables:
                                        </p>
                                        <ul>
                                            <li>Chi-square test of independence: Compares observed vs. expected frequencies</li>
                                            <li>Fisher's exact test: Better for small sample sizes</li>
                                            <li>G-test: Alternative to chi-square based on likelihood ratio</li>
                                        </ul>
                                        <p>
                                            For continuous variables:
                                        </p>
                                        <ul>
                                            <li>Pearson correlation coefficient: Tests for linear relationships</li>
                                            <li>Spearman's rank correlation: Non-parametric test for monotonic relationships</li>
                                            <li>Kendall's tau: Alternative rank correlation measure</li>
                                            <li>Mutual information: Detects any type of dependency, not just linear</li>
                                            <li>Distance correlation: Can detect non-linear relationships</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* Computer Science - Algorithms */}
                        <section className={`section ${activeSection === 'cs-algorithms' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Algorithms</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Knowledge of classical algorithms and programming techniques is essential for implementing efficient 
                                    machine learning solutions. Key areas include sorting algorithms, dynamic programming, tree traversals, 
                                    and efficient data processing.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="algo-1">
                                    <div className={`question ${openQAs['algo-1'] ? 'open' : ''}`} onClick={() => toggleQA('algo-1')}>
                                        Time complexity of common sorting algorithms
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['algo-1'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Quick Sort: O(n log n) average case, O(n²) worst case</li>
                                            <li>Merge Sort: O(n log n) for all cases</li>
                                            <li>Bubble Sort: O(n²)</li>
                                            <li>Insertion Sort: O(n²) worst/average case, O(n) best case</li>
                                            <li>Heap Sort: O(n log n)</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="algo-2">
                                    <div className={`question ${openQAs['algo-2'] ? 'open' : ''}`} onClick={() => toggleQA('algo-2')}>
                                        Tree traversal methods
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['algo-2'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Pre-order: Visit root, then left subtree, then right subtree</li>
                                            <li>In-order: Visit left subtree, then root, then right subtree (gives sorted order for BST)</li>
                                            <li>Post-order: Visit left subtree, then right subtree, then root</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="algo-3">
                                    <div className={`question ${openQAs['algo-3'] ? 'open' : ''}`} onClick={() => toggleQA('algo-3')}>
                                        Key algorithm problems in ML interviews
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['algo-3'] ? 'open' : ''}`}>
                                        <p>Common algorithm problems in ML interviews include:</p>
                                        <ol>
                                            <li>Recursive JSON file reading</li>
                                            <li>O(N log N) sorting implementations</li>
                                            <li>Finding longest increasing/common subsequences</li>
                                            <li>Tree traversals</li>
                                            <li>Continuous subarray sum problems</li>
                                            <li>Finding median of sorted arrays</li>
                                            <li>Sudoku solvers</li>
                                            <li>Memory management implementation</li>
                                            <li>Mathematical expression parsers/calculators</li>
                                            <li>File duplicate detection</li>
                                        </ol>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* Computer Science - Complexity & Numerical Analysis */}
                        <section className={`section ${activeSection === 'cs-complexity' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Complexity & Numerical Analysis</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Understanding computational complexity and numerical stability is crucial for scaling ML models and ensuring 
                                    reliable performance. This area covers matrix calculations, numerical precision, hardware considerations, 
                                    and optimization techniques for deep learning.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="complex-1">
                                    <div className={`question ${openQAs['complex-1'] ? 'open' : ''}`} onClick={() => toggleQA('complex-1')}>
                                        Causes of numerical instability in deep learning
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['complex-1'] ? 'open' : ''}`}>
                                        <ol>
                                            <li>Vanishing/exploding gradients</li>
                                            <li>Poor weight initialization</li>
                                            <li>Very large or small values leading to overflow/underflow</li>
                                            <li>Division by values close to zero</li>
                                            <li>Loss of precision in floating-point arithmetic</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="complex-2">
                                    <div className={`question ${openQAs['complex-2'] ? 'open' : ''}`} onClick={() => toggleQA('complex-2')}>
                                        Purpose of epsilon term
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['complex-2'] ? 'open' : ''}`}>
                                        <p>
                                            The small epsilon term (e.g., in batch norm) prevents division by zero, stabilizes computation, 
                                            and improves numerical stability without significantly affecting the mathematical properties of the operation.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="complex-3">
                                    <div className={`question ${openQAs['complex-3'] ? 'open' : ''}`} onClick={() => toggleQA('complex-3')}>
                                        GPU advantages for deep learning
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['complex-3'] ? 'open' : ''}`}>
                                        <p>
                                            GPUs excel at parallel processing of matrix operations, which are fundamental to deep learning. Compared to TPUs, GPUs are:
                                        </p>
                                        <ul>
                                            <li>More flexible and general-purpose</li>
                                            <li>Widely available and supported</li>
                                            <li>Better for development and experimentation</li>
                                        </ul>
                                        <p>
                                            TPUs are more specialized for specific operations and can be more efficient for production deployment of certain models.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="complex-4">
                                    <div className={`question ${openQAs['complex-4'] ? 'open' : ''}`} onClick={() => toggleQA('complex-4')}>
                                        What makes a problem intractable
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['complex-4'] ? 'open' : ''}`}>
                                        <p>
                                            A problem is intractable when it cannot be solved in polynomial time (NP-hard problems). 
                                            As input size grows, the computational resources required grow exponentially, making practical 
                                            solutions infeasible beyond small problem instances.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="complex-5">
                                    <div className={`question ${openQAs['complex-5'] ? 'open' : ''}`} onClick={() => toggleQA('complex-5')}>
                                        Matrix multiplication optimization
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['complex-5'] ? 'open' : ''}`}>
                                        <p>
                                            For matrices A ∈ R^(100×5), B ∈ R^(5×200), C ∈ R^(200×20), you should compute (AB)C instead of A(BC).
                                        </p>
                                        <p>
                                            This is because (AB) gives a 100×200 matrix which multiplied by C results in 100×20, requiring 100×200×20 = 400,000 operations.
                                        </p>
                                        <p>
                                            Computing A(BC) would first give a 5×20 matrix, then require 100×5×20 = 10,000 operations.
                                        </p>
                                        <p>
                                            The order of multiplication significantly impacts computational efficiency.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* Computer Science - Data Structures & Data Handling */}
                        <section className={`section ${activeSection === 'cs-data-structures' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Data Structures & Data Handling</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Effective data management is critical for ML applications, from storing and processing to monitoring data pipelines.
                                    Understanding data structures and formats helps create efficient ML workflows and systems.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="data-1">
                                    <div className={`question ${openQAs['data-1'] ? 'open' : ''}`} onClick={() => toggleQA('data-1')}>
                                        Key data structures for ML
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['data-1'] ? 'open' : ''}`}>
                                        <p>Essential data structures to know:</p>
                                        <ul>
                                            <li>Trees: binary search tree, heap, trie (prefix and suffix tree)</li>
                                            <li>Queues, stacks, priority queues</li>
                                            <li>Linked lists</li>
                                            <li>HashMap and HashTable</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="data-2">
                                    <div className={`question ${openQAs['data-2'] ? 'open' : ''}`} onClick={() => toggleQA('data-2')}>
                                        Data format considerations
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['data-2'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Row-based formats (CSV, JSON) vs. column-based formats (Parquet, ORC)</li>
                                            <li>Write efficiency vs. read efficiency</li>
                                            <li>Data manipulation frameworks (pandas, dask)</li>
                                            <li>Visualization libraries (seaborn, matplotlib, Tableau, ggplot)</li>
                                            <li>Distributed data systems (Spark, Hadoop)</li>
                                            <li>SQL for database queries</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Fundamentals - ML Basics */}
                        <section className={`section ${activeSection === 'ml-basics' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>ML Basics</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Foundational machine learning concepts and principles. This covers supervised vs. unsupervised learning, 
                                    model complexity, regularization approaches, and fundamental theory behind machine learning.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="mlb-1">
                                    <div className={`question ${openQAs['mlb-1'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-1')}>
                                        Supervised vs. unsupervised learning
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-1'] ? 'open' : ''}`}>
                                        <p>
                                            Types of learning paradigms:
                                        </p>
                                        <ul>
                                            <li><strong>Supervised learning:</strong> Model learns from labeled data with input-output pairs</li>
                                            <li><strong>Unsupervised learning:</strong> Model discovers patterns from unlabeled data</li>
                                            <li><strong>Semi-supervised learning:</strong> Uses small amount of labeled data with large unlabeled dataset</li>
                                            <li><strong>Weakly supervised learning:</strong> Uses noisy, limited, or imprecise sources for supervision</li>
                                            <li><strong>Active learning:</strong> Algorithm selects which data points to label to maximize learning</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-2">
                                    <div className={`question ${openQAs['mlb-2'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-2')}>
                                        Empirical risk minimization
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-2'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>The "risk" is the expected loss/error over the entire data distribution</li>
                                            <li>It's "empirical" because we estimate it using a finite training dataset</li>
                                            <li>We minimize risk by adjusting model parameters to reduce training error</li>
                                        </ul>
                                        <p>
                                            Mathematically: R(f) = E[L(f(x), y)] ≈ (1/n)∑L(f(x_i), y_i)
                                        </p>
                                        <p>
                                            The key challenge is ensuring that minimizing empirical risk generalizes to unseen data.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-3">
                                    <div className={`question ${openQAs['mlb-3'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-3')}>
                                        Occam's razor in ML
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-3'] ? 'open' : ''}`}>
                                        <p>
                                            Occam's razor applies to ML through:
                                        </p>
                                        <ul>
                                            <li>Preferring simpler models when they perform comparably to complex ones</li>
                                            <li>Regularization techniques that penalize model complexity</li>
                                            <li>Feature selection to remove unnecessary inputs</li>
                                            <li>Model selection criteria that balance fit and complexity (AIC, BIC)</li>
                                            <li>Pruning techniques in decision trees</li>
                                        </ul>
                                        <p>
                                            This principle helps prevent overfitting and improves generalization.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-4">
                                    <div className={`question ${openQAs['mlb-4'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-4')}>
                                        Deep learning popularity factors
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-4'] ? 'open' : ''}`}>
                                        <p>
                                            Conditions that enabled deep learning's rise:
                                        </p>
                                        <ol>
                                            <li>Availability of large labeled datasets (e.g., ImageNet)</li>
                                            <li>Increased computational power, especially GPUs</li>
                                            <li>Algorithmic improvements (ReLU, better initialization, normalization techniques)</li>
                                            <li>Software frameworks making implementation accessible (TensorFlow, PyTorch)</li>
                                            <li>Architectural innovations (CNNs, RNNs, Transformers)</li>
                                            <li>Industry investment and open research sharing</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-5">
                                    <div className={`question ${openQAs['mlb-5'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-5')}>
                                        Wide vs. deep neural networks
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-5'] ? 'open' : ''}`}>
                                        <p>
                                            Deep networks are more expressive than wide networks with the same parameter count because:
                                        </p>
                                        <ul>
                                            <li>Deep networks create a hierarchical feature representation</li>
                                            <li>Each layer can build upon features learned in previous layers</li>
                                            <li>Deep networks can represent exponentially more regions in input space</li>
                                            <li>Certain functions require exponentially more parameters in a shallow network</li>
                                            <li>Deep networks can more efficiently represent compositional functions</li>
                                        </ul>
                                        <p>
                                            However, deep networks can be harder to train due to vanishing/exploding gradients.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-6">
                                    <div className={`question ${openQAs['mlb-6'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-6')}>
                                        Universal Approximation Theorem limitations
                                        <span className="difficulty hard">Hard</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-6'] ? 'open' : ''}`}>
                                        <p>
                                            While the Universal Approximation Theorem states a neural network with 1 hidden layer can approximate any continuous function, in practice it can't achieve arbitrarily small error because:
                                        </p>
                                        <ul>
                                            <li>The theorem is existential (says such networks exist) but not constructive (doesn't tell us how to find them)</li>
                                            <li>The width of the hidden layer might need to be impractically large</li>
                                            <li>Optimization algorithms may not find the global minimum</li>
                                            <li>Limited training data makes perfect approximation impossible (overfitting concerns)</li>
                                            <li>Numerical precision limitations in computation</li>
                                            <li>Regularization techniques deliberately limit model capacity</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-7">
                                    <div className={`question ${openQAs['mlb-7'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-7')}>
                                        Saddle points vs. local minima
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-7'] ? 'open' : ''}`}>
                                        <p>
                                            In neural network optimization:
                                        </p>
                                        <ul>
                                            <li><strong>Local minima:</strong> Points where the function value is lower than all nearby points</li>
                                            <li><strong>Saddle points:</strong> Points where the gradient is zero but it's neither a maximum nor a minimum (some directions curve up, others down)</li>
                                        </ul>
                                        <p>
                                            In high-dimensional spaces (like deep neural networks), saddle points are much more common than local minima. This is because for a local minimum, all dimensions must curve upward simultaneously, which becomes exponentially unlikely as dimensions increase.
                                        </p>
                                        <p>
                                            Saddle points pose greater training challenges in deep learning, as gradient-based methods may slow down significantly near them.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-8">
                                    <div className={`question ${openQAs['mlb-8'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-8')}>
                                        Parameters vs. hyperparameters
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-8'] ? 'open' : ''}`}>
                                        <p>
                                            Parameters vs. hyperparameters:
                                        </p>
                                        <ul>
                                            <li><strong>Parameters:</strong> Internal model variables learned from training data (e.g., weights, biases)</li>
                                            <li><strong>Hyperparameters:</strong> External configurations set before training (e.g., learning rate, regularization strength, network architecture)</li>
                                        </ul>
                                        <p>
                                            Hyperparameter tuning is important because:
                                        </p>
                                        <ul>
                                            <li>Can significantly impact model performance and convergence</li>
                                            <li>Helps prevent overfitting or underfitting</li>
                                            <li>Different datasets and tasks require different configurations</li>
                                            <li>Can compensate for limitations in data or model architecture</li>
                                        </ul>
                                        <p>
                                            Common tuning methods: grid search, random search, Bayesian optimization, or genetic algorithms.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-9">
                                    <div className={`question ${openQAs['mlb-9'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-9')}>
                                        L1 vs. L2 regularization effects
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-9'] ? 'open' : ''}`}>
                                        <p>
                                            L1 regularization (Lasso) encourages sparsity because:
                                        </p>
                                        <ul>
                                            <li>The L1 penalty (absolute value) doesn't change uniformly with parameter values</li>
                                            <li>For small weights, the gradient of the L1 penalty has constant magnitude</li>
                                            <li>This can push weights exactly to zero, creating sparse solutions</li>
                                            <li>Geometrically, L1 constraint regions have corners at coordinate axes</li>
                                        </ul>
                                        <p>
                                            L2 regularization (Ridge) pushes weights toward zero but rarely to exactly zero because:
                                        </p>
                                        <ul>
                                            <li>The L2 penalty (squared value) increases quadratically with parameter magnitude</li>
                                            <li>The gradient of the L2 penalty gets smaller as weights approach zero</li>
                                            <li>This creates a "diminishing returns" effect that rarely pushes weights exactly to zero</li>
                                            <li>Geometrically, L2 constraint regions are circular/spherical without corners</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="mlb-10">
                                    <div className={`question ${openQAs['mlb-10'] ? 'open' : ''}`} onClick={() => toggleQA('mlb-10')}>
                                        Model performance degradation in production
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['mlb-10'] ? 'open' : ''}`}>
                                        <p>
                                            Common reasons for ML model performance degradation in production:
                                        </p>
                                        <ul>
                                            <li>Data drift: Distribution of input data changes over time</li>
                                            <li>Concept drift: Relationship between features and target variable changes</li>
                                            <li>Feature engineering pipeline differences between training and production</li>
                                            <li>Different performance metrics in development vs. production</li>
                                            <li>Feedback loops where model predictions affect future data</li>
                                            <li>Hardware/software environment differences affecting numerical precision</li>
                                            <li>Training data leakage that doesn't exist in production</li>
                                            <li>Seasonality or temporal patterns not captured in training</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Fundamentals - Sampling & Training Data */}
                        <section className={`section ${activeSection === 'ml-sampling' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Sampling & Creating Training Data</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Effective data sampling and preparation strategies are crucial for model training and performance.
                                    This includes sampling methods, handling practical challenges, addressing data quality issues, and
                                    preventing data leakage.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="sampling-1">
                                    <div className={`question ${openQAs['sampling-1'] ? 'open' : ''}`} onClick={() => toggleQA('sampling-1')}>
                                        Sampling with vs. without replacement
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['sampling-1'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>With replacement: Same item can be selected multiple times (models independent draws)</li>
                                            <li>Without replacement: Once selected, an item cannot be selected again (models dependent draws)</li>
                                        </ul>
                                        <p>
                                            Use with replacement for modeling processes where events are independent, without replacement when 
                                            sampling from a finite population.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="sampling-2">
                                    <div className={`question ${openQAs['sampling-2'] ? 'open' : ''}`} onClick={() => toggleQA('sampling-2')}>
                                        MCMC sampling
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['sampling-2'] ? 'open' : ''}`}>
                                        <p>
                                            Markov Chain Monte Carlo methods generate samples from a probability distribution by constructing a Markov chain 
                                            that has the target distribution as its equilibrium distribution. The samples are correlated, but as the chain 
                                            runs longer, they approximate the target distribution.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="sampling-3">
                                    <div className={`question ${openQAs['sampling-3'] ? 'open' : ''}`} onClick={() => toggleQA('sampling-3')}>
                                        Handling class imbalance
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['sampling-3'] ? 'open' : ''}`}>
                                        <ol>
                                            <li>Resampling: Oversampling minority class or undersampling majority class</li>
                                            <li>Synthetic data generation: SMOTE, ADASYN</li>
                                            <li>Cost-sensitive learning: Higher penalties for misclassifying minority class</li>
                                            <li>Ensemble methods: Balanced bagging, boosting</li>
                                            <li>Focal loss or other specialized loss functions</li>
                                            <li>Evaluation metrics: Use F1-score, precision-recall AUC instead of accuracy</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="sampling-4">
                                    <div className={`question ${openQAs['sampling-4'] ? 'open' : ''}`} onClick={() => toggleQA('sampling-4')}>
                                        Training data leakage
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['sampling-4'] ? 'open' : ''}`}>
                                        <p>
                                            Leakage occurs when information from outside the training set is used in the model building process. Examples:
                                        </p>
                                        <ul>
                                            <li>Performing preprocessing (like normalization) on the entire dataset</li>
                                            <li>Oversampling before splitting data</li>
                                            <li>Using future information to predict past events</li>
                                            <li>Having duplicate or highly correlated samples across splits</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="sampling-5">
                                    <div className={`question ${openQAs['sampling-5'] ? 'open' : ''}`} onClick={() => toggleQA('sampling-5')}>
                                        Feature leakage
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['sampling-5'] ? 'open' : ''}`}>
                                        <p>
                                            Feature leakage happens when a feature contains information that wouldn't be available at prediction time 
                                            or directly/indirectly contains the target information. Examples:
                                        </p>
                                        <ul>
                                            <li>Using future data to create features</li>
                                            <li>Features highly correlated with the target due to data collection process</li>
                                            <li>Proxy variables that indirectly encode the target</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Fundamentals - Metrics & Evaluation */}
                        <section className={`section ${activeSection === 'ml-evaluation' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Objective Functions, Metrics & Evaluation</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Understanding how to properly evaluate models and select appropriate metrics is essential for ML success.
                                    This includes convergence definitions, bias-variance tradeoff, validation methods, and specific metrics
                                    for classification and regression tasks.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="eval-1">
                                    <div className={`question ${openQAs['eval-1'] ? 'open' : ''}`} onClick={() => toggleQA('eval-1')}>
                                        Convergence meaning
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-1'] ? 'open' : ''}`}>
                                        <p>
                                            An algorithm converges when additional iterations produce negligible improvements in the objective function. 
                                            Practically, we say a model has converged when the change in loss between epochs falls below a predefined threshold.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="eval-2">
                                    <div className={`question ${openQAs['eval-2'] ? 'open' : ''}`} onClick={() => toggleQA('eval-2')}>
                                        Bias-variance tradeoff
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-2'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Bias: Error from simplified assumptions in the model (underfitting)</li>
                                            <li>Variance: Error from sensitivity to fluctuations in training data (overfitting)</li>
                                        </ul>
                                        <p>
                                            Increasing model complexity typically decreases bias but increases variance, and vice versa.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="eval-3">
                                    <div className={`question ${openQAs['eval-3'] ? 'open' : ''}`} onClick={() => toggleQA('eval-3')}>
                                        High variance, low bias indicators and solutions
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-3'] ? 'open' : ''}`}>
                                        <p>Indicators:</p>
                                        <ul>
                                            <li>Low training error, high validation error</li>
                                            <li>Model performs well on training data but poorly on new data</li>
                                            <li>Large gap between training and validation performance</li>
                                        </ul>
                                        <p>Solutions:</p>
                                        <ul>
                                            <li>More data</li>
                                            <li>Regularization</li>
                                            <li>Simpler model</li>
                                            <li>Dropout</li>
                                            <li>Early stopping</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="eval-4">
                                    <div className={`question ${openQAs['eval-4'] ? 'open' : ''}`} onClick={() => toggleQA('eval-4')}>
                                        Cross-validation methods
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-4'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>k-fold: Split data into k subsets, train on k-1 and validate on the remaining one, rotate k times</li>
                                            <li>Stratified k-fold: Like k-fold but maintains class distribution in each fold</li>
                                            <li>Leave-one-out: Train on all data except one point, validate on that point, repeat for all points</li>
                                            <li>Time series split: Respects temporal order for time series data</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="eval-5">
                                    <div className={`question ${openQAs['eval-5'] ? 'open' : ''}`} onClick={() => toggleQA('eval-5')}>
                                        Why less cross-validation in deep learning
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-5'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Computationally expensive</li>
                                            <li>Often have dedicated validation sets</li>
                                            <li>Modern deep learning uses other regularization techniques</li>
                                            <li>Batch normalization, dropout, and data augmentation provide built-in regularization</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="eval-6">
                                    <div className={`question ${openQAs['eval-6'] ? 'open' : ''}`} onClick={() => toggleQA('eval-6')}>
                                        F1 score benefits over accuracy
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-6'] ? 'open' : ''}`}>
                                        <p>
                                            F1 score (harmonic mean of precision and recall) is better than accuracy for imbalanced datasets because:
                                        </p>
                                        <ul>
                                            <li>Accounts for both false positives and false negatives</li>
                                            <li>Sensitive to class imbalance</li>
                                            <li>Balanced measure for precision-recall tradeoff</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="eval-7">
                                    <div className={`question ${openQAs['eval-7'] ? 'open' : ''}`} onClick={() => toggleQA('eval-7')}>
                                        Why log loss for logistic regression over MSE
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-7'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Log loss provides stronger gradients when predictions are far from targets</li>
                                            <li>Mathematically derived from maximum likelihood estimation</li>
                                            <li>Heavily penalizes confident wrong predictions</li>
                                            <li>Asymptotically approaches infinity as prediction approaches wrong label</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="eval-8">
                                    <div className={`question ${openQAs['eval-8'] ? 'open' : ''}`} onClick={() => toggleQA('eval-8')}>
                                        RMSE vs. MAE
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['eval-8'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>RMSE (Root Mean Squared Error): Penalizes large errors more, sensitive to outliers</li>
                                            <li>MAE (Mean Absolute Error): Treats all error magnitudes linearly, more robust to outliers</li>
                                        </ul>
                                        <p>
                                            Use RMSE when large errors are particularly undesirable, and MAE when you want more robustness to outliers.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Methods - Classical ML */}
                        <section className={`section ${activeSection === 'ml-classical' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Classical Machine Learning</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Traditional machine learning algorithms and techniques that form the foundation of modern ML.
                                    This includes regression, clustering, ensemble methods, dimensionality reduction, and feature selection techniques.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="classic-1">
                                    <div className={`question ${openQAs['classic-1'] ? 'open' : ''}`} onClick={() => toggleQA('classic-1')}>
                                        Linear regression assumptions
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-1'] ? 'open' : ''}`}>
                                        <p>
                                            Basic assumptions for linear regression:
                                        </p>
                                        <ol>
                                            <li>Linearity: Relationship between features and target is linear</li>
                                            <li>Independence: Observations are independent of each other</li>
                                            <li>Homoscedasticity: Error variance is constant across all feature values</li>
                                            <li>Normality: Errors follow a normal distribution</li>
                                            <li>No multicollinearity: Predictor variables are not highly correlated</li>
                                            <li>No endogeneity: Error terms are uncorrelated with predictor variables</li>
                                        </ol>
                                        <p>
                                            Violating these assumptions can lead to biased coefficients, incorrect standard errors, or inefficient estimates.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-2">
                                    <div className={`question ${openQAs['classic-2'] ? 'open' : ''}`} onClick={() => toggleQA('classic-2')}>
                                        Feature scaling in logistic regression
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-2'] ? 'open' : ''}`}>
                                        <p>
                                            Without feature scaling in logistic regression:
                                        </p>
                                        <ul>
                                            <li>Features with larger scales will dominate the gradient updates</li>
                                            <li>Convergence will be slower and may require more iterations</li>
                                            <li>Risk of numerical instability during optimization</li>
                                            <li>Regularization will penalize different features unequally</li>
                                            <li>The learning rate may be appropriate for some features but not others</li>
                                        </ul>
                                        <p>
                                            Most gradient-based optimization algorithms assume features are on similar scales.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-3">
                                    <div className={`question ${openQAs['classic-3'] ? 'open' : ''}`} onClick={() => toggleQA('classic-3')}>
                                        Feature selection importance
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-3'] ? 'open' : ''}`}>
                                        <p>
                                            We use feature selection for:
                                        </p>
                                        <ul>
                                            <li>Reducing model complexity and computational requirements</li>
                                            <li>Mitigating overfitting by removing noise and redundancy</li>
                                            <li>Improving model interpretability with fewer features</li>
                                            <li>Reducing data collection/storage needs for irrelevant features</li>
                                            <li>Avoiding the curse of dimensionality</li>
                                            <li>Faster training and inference times</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-4">
                                    <div className={`question ${openQAs['classic-4'] ? 'open' : ''}`} onClick={() => toggleQA('classic-4')}>
                                        Feature selection algorithms
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-4'] ? 'open' : ''}`}>
                                        <p>
                                            Filter methods:
                                        </p>
                                        <ul>
                                            <li>Select features independently of the model</li>
                                            <li>Examples: chi-square test, correlation, mutual information</li>
                                            <li>Pros: Fast, model-agnostic</li>
                                            <li>Cons: Ignore feature interactions and model specifics</li>
                                        </ul>
                                        <p>
                                            Wrapper methods:
                                        </p>
                                        <ul>
                                            <li>Evaluate subsets of features using the model</li>
                                            <li>Examples: forward selection, backward elimination, recursive feature elimination</li>
                                            <li>Pros: Consider feature interactions, model-specific</li>
                                            <li>Cons: Computationally expensive, risk of overfitting</li>
                                        </ul>
                                        <p>
                                            Embedded methods:
                                        </p>
                                        <ul>
                                            <li>Perform feature selection during model training</li>
                                            <li>Examples: LASSO, elastic net, tree-based importance</li>
                                            <li>Pros: Balance between filter and wrapper methods</li>
                                            <li>Cons: Limited to certain types of models</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-5">
                                    <div className={`question ${openQAs['classic-5'] ? 'open' : ''}`} onClick={() => toggleQA('classic-5')}>
                                        K-means clustering: choosing k
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-5'] ? 'open' : ''}`}>
                                        <p>
                                            Methods for choosing the optimal k value:
                                        </p>
                                        <ul>
                                            <li>Elbow method: Plot inertia (within-cluster sum of squares) vs. k and look for the "elbow" point</li>
                                            <li>Silhouette score: Measure how similar points are to their own cluster vs. other clusters</li>
                                            <li>Gap statistic: Compare inertia to a null reference distribution</li>
                                            <li>Domain knowledge: Use prior knowledge about natural groupings</li>
                                            <li>Business requirements: Consider practical needs for number of segments</li>
                                            <li>Cross-validation: Evaluate downstream task performance with different k values</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-6">
                                    <div className={`question ${openQAs['classic-6'] ? 'open' : ''}`} onClick={() => toggleQA('classic-6')}>
                                        K-means vs GMM comparison
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-6'] ? 'open' : ''}`}>
                                        <p>
                                            K-means:
                                        </p>
                                        <ul>
                                            <li>Assigns points to nearest centroid based on Euclidean distance</li>
                                            <li>Creates spherical clusters of similar sizes</li>
                                            <li>Hard assignments (each point belongs to exactly one cluster)</li>
                                            <li>Faster and simpler computationally</li>
                                            <li>Less expressive but more robust with limited data</li>
                                        </ul>
                                        <p>
                                            Gaussian Mixture Models (GMM):
                                        </p>
                                        <ul>
                                            <li>Models clusters as multivariate Gaussian distributions</li>
                                            <li>Can capture elliptical clusters of varying shapes, sizes, and orientations</li>
                                            <li>Soft assignments (probabilistic membership to multiple clusters)</li>
                                            <li>Provides uncertainty estimates through probabilities</li>
                                            <li>More computationally intensive but more flexible</li>
                                        </ul>
                                        <p>
                                            Choose GMM when: clusters have different shapes/sizes, need probability estimates, or when clusters overlap. Choose K-means for speed, simplicity, or when clusters are roughly spherical and similar in size.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-7">
                                    <div className={`question ${openQAs['classic-7'] ? 'open' : ''}`} onClick={() => toggleQA('classic-7')}>
                                        Bagging vs. boosting
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-7'] ? 'open' : ''}`}>
                                        <p>
                                            Bagging (Bootstrap Aggregating):
                                        </p>
                                        <ul>
                                            <li>Trains models in parallel on bootstrap samples of the data</li>
                                            <li>Combines results through averaging (regression) or voting (classification)</li>
                                            <li>Reduces variance without affecting bias much</li>
                                            <li>Models are independent of each other</li>
                                            <li>Example: Random Forest</li>
                                        </ul>
                                        <p>
                                            Boosting:
                                        </p>
                                        <ul>
                                            <li>Trains models sequentially, each focusing on errors of previous models</li>
                                            <li>Assigns weights to training instances based on difficulty</li>
                                            <li>Reduces bias primarily, may increase variance if not careful</li>
                                            <li>Models depend on previous ones in the sequence</li>
                                            <li>Examples: AdaBoost, Gradient Boosting, XGBoost</li>
                                        </ul>
                                        <p>
                                            In deep learning, bagging can be seen in techniques like dropout and model ensembling, while boosting concepts appear in curriculum learning and hard example mining.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-8">
                                    <div className={`question ${openQAs['classic-8'] ? 'open' : ''}`} onClick={() => toggleQA('classic-8')}>
                                        Naive Bayes classifier naivety
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-8'] ? 'open' : ''}`}>
                                        <p>
                                            Naive Bayes is "naive" because:
                                        </p>
                                        <ul>
                                            <li>It assumes all features are conditionally independent given the class</li>
                                            <li>This assumption is rarely true in real-world data</li>
                                            <li>It treats each feature's contribution to the probability as completely separate</li>
                                            <li>It ignores any correlations or interactions between features</li>
                                        </ul>
                                        <p>
                                            Despite this simplifying assumption, Naive Bayes often performs well in practice, especially for text classification and with small datasets. The independence assumption allows for efficient parameter estimation with limited data.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-9">
                                    <div className={`question ${openQAs['classic-9'] ? 'open' : ''}`} onClick={() => toggleQA('classic-9')}>
                                        Gradient boosting explanation
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-9'] ? 'open' : ''}`}>
                                        <p>
                                            Gradient boosting:
                                        </p>
                                        <ol>
                                            <li>Starts with a simple model (e.g., average of target values)</li>
                                            <li>Calculates the residual errors (difference between predictions and actual values)</li>
                                            <li>Trains a new "weak learner" to predict these residuals</li>
                                            <li>Adds this new model to the ensemble (typically scaled by a learning rate)</li>
                                            <li>Updates predictions and calculates new residuals</li>
                                            <li>Repeats steps 3-5 for a specified number of iterations</li>
                                        </ol>
                                        <p>
                                            It works well for:
                                        </p>
                                        <ul>
                                            <li>Tabular data with numerical and categorical features</li>
                                            <li>Regression and classification problems</li>
                                            <li>Heterogeneous data with complex relationships</li>
                                            <li>Competitions and industry applications where accuracy is paramount</li>
                                            <li>Problems where feature interactions are important</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="classic-10">
                                    <div className={`question ${openQAs['classic-10'] ? 'open' : ''}`} onClick={() => toggleQA('classic-10')}>
                                        SVM linear separation
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['classic-10'] ? 'open' : ''}`}>
                                        <p>
                                            Linear separation in SVM means:
                                        </p>
                                        <ul>
                                            <li>Data points from different classes can be completely separated by a hyperplane</li>
                                            <li>No misclassifications exist when using this hyperplane as a decision boundary</li>
                                        </ul>
                                        <p>
                                            Linear separation is desirable because:
                                        </p>
                                        <ul>
                                            <li>It allows SVMs to find the optimal separating hyperplane with maximum margin</li>
                                            <li>The optimization problem becomes convex with a unique solution</li>
                                            <li>Training is more efficient and stable</li>
                                            <li>Generalization tends to be better with larger margins</li>
                                        </ul>
                                        <p>
                                            When data isn't linearly separable, SVMs can use:
                                        </p>
                                        <ul>
                                            <li>Soft margin: Allow some misclassifications with penalty</li>
                                            <li>Kernel trick: Implicitly transform data to higher dimensions where it becomes linearly separable</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Methods - NLP */}
                        <section className={`section ${activeSection === 'ml-nlp' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Natural Language Processing</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    NLP techniques for processing and understanding human language data. Key areas include
                                    recurrent architectures, language modeling approaches, word representations, and model evaluation methods.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="nlp-1">
                                    <div className={`question ${openQAs['nlp-1'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-1')}>
                                        RNN motivation
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-1'] ? 'open' : ''}`}>
                                        <p>
                                            RNNs (Recurrent Neural Networks) were developed to handle sequential data where the order matters and 
                                            context from previous inputs should influence current outputs. They maintain a hidden state that captures 
                                            information from previous time steps.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="nlp-2">
                                    <div className={`question ${openQAs['nlp-2'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-2')}>
                                        LSTM motivation
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-2'] ? 'open' : ''}`}>
                                        <p>
                                            LSTMs (Long Short-Term Memory) address the vanishing gradient problem in standard RNNs, which makes them unable 
                                            to capture long-range dependencies. LSTMs use gate mechanisms to control information flow, allowing them to 
                                            remember relevant information over longer sequences.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="nlp-3">
                                    <div className={`question ${openQAs['nlp-3'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-3')}>
                                        Word embeddings necessity
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-3'] ? 'open' : ''}`}>
                                        <p>
                                            Word embeddings are essential because they:
                                        </p>
                                        <ul>
                                            <li>Convert discrete word tokens into continuous vector spaces where semantic relationships are preserved</li>
                                            <li>Reduce dimensionality compared to one-hot encoding (e.g., from vocabulary size to 300 dimensions)</li>
                                            <li>Enable meaningful mathematical operations on words (like finding analogies)</li>
                                            <li>Allow neural networks to process words effectively</li>
                                            <li>Help models generalize across similar words (e.g., "apple" and "orange" will have similar representations)</li>
                                            <li>Enable transfer learning from large text corpora to smaller tasks</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="nlp-4">
                                    <div className={`question ${openQAs['nlp-4'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-4')}>
                                        N-gram vs. neural language models
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-4'] ? 'open' : ''}`}>
                                        <p>
                                            For small datasets (10,000 tokens):
                                        </p>
                                        <p>
                                            N-gram models are preferable as they:
                                        </p>
                                        <ul>
                                            <li>Don't require large amounts of training data</li>
                                            <li>Have fewer parameters to estimate</li>
                                            <li>Less prone to overfitting</li>
                                            <li>Computationally simpler</li>
                                        </ul>
                                        <p>
                                            Neural models generally need much more data to perform well.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="nlp-5">
                                    <div className={`question ${openQAs['nlp-5'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-5')}>
                                        Language model as density estimator
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-5'] ? 'open' : ''}`}>
                                        <p>
                                            A language model is a density estimator because:
                                        </p>
                                        <ul>
                                            <li>It estimates the probability distribution of sequences of words/tokens in a language</li>
                                            <li>It assigns probabilities to sequences, indicating how likely they are to occur</li>
                                            <li>It models the joint probability of words in a sequence P(w₁, w₂, ..., wₙ)</li>
                                            <li>The sum of probabilities for all possible sequences equals 1</li>
                                        </ul>
                                    </div>
                                </div>

                                <div className="qa-item" data-qa-id="nlp-6">
                                    <div className={`question ${openQAs['nlp-6'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-6')}>
                                        Count vs. prediction word embeddings
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-6'] ? 'open' : ''}`}>
                                        <p>
                                            Count-based embeddings:
                                        </p>
                                        <ul>
                                            <li>Based on co-occurrence statistics of words in corpus</li>
                                            <li>Examples: LSA, HAL, COALS, GloVe</li>
                                            <li>Process: Count co-occurrences, apply dimensionality reduction</li>
                                            <li>Often use SVD or similar techniques for dimension reduction</li>
                                            <li>Computationally efficient for training</li>
                                        </ul>
                                        <p>
                                            Prediction-based embeddings:
                                        </p>
                                        <ul>
                                            <li>Learn word vectors by predicting context words</li>
                                            <li>Examples: Word2Vec (CBOW, Skip-gram), ELMo</li>
                                            <li>Usually trained with neural networks</li>
                                            <li>Often capture more semantic information</li>
                                            <li>Can be more computationally intensive to train</li>
                                            <li>Generally perform better on semantic tasks</li>
                                        </ul>
                                    </div>
                                </div>

                                <div className="qa-item" data-qa-id="nlp-7">
                                    <div className={`question ${openQAs['nlp-7'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-7')}>
                                        RNN dropout techniques
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-7'] ? 'open' : ''}`}>
                                        <p>
                                            Implementing dropout in RNNs requires special consideration:
                                        </p>
                                        <ul>
                                            <li>Vanilla dropout on hidden states can disrupt temporal information flow</li>
                                            <li>Variational dropout: Apply the same dropout mask across all time steps</li>
                                            <li>Zoneout: Randomly keep previous hidden states instead of updating</li>
                                            <li>Recurrent dropout: Apply dropout only to the recurrent connections</li>
                                            <li>Weight dropout: Apply dropout to the weight matrices instead of activations</li>
                                        </ul>
                                    </div>
                                </div>

                                <div className="qa-item" data-qa-id="nlp-8">
                                    <div className={`question ${openQAs['nlp-8'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-8')}>
                                        Context-based word embedding limitations
                                        <span className="difficulty hard">Hard</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-8'] ? 'open' : ''}`}>
                                        <p>
                                            Problems with context-based word embeddings:
                                        </p>
                                        <ul>
                                            <li>Polysemy: Single representation for words with multiple meanings (e.g., "bank" as financial institution vs. river bank)</li>
                                            <li>Static nature: Each word has same vector regardless of context</li>
                                            <li>Window-based context may miss long-range dependencies</li>
                                            <li>May encode societal biases present in the training corpus</li>
                                            <li>Difficulty handling rare words or out-of-vocabulary words</li>
                                            <li>Cannot capture compositional semantics well (meaning of phrases)</li>
                                        </ul>
                                        <p>
                                            Newer contextual embeddings (BERT, ELMo) address some of these limitations by generating dynamic embeddings based on context.
                                        </p>
                                    </div>
                                </div>

                                <div className="qa-item" data-qa-id="nlp-9">
                                    <div className={`question ${openQAs['nlp-9'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-9')}>
                                        Language model as unsupervised vs supervised
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-9'] ? 'open' : ''}`}>
                                        <p>
                                            Language models are considered unsupervised because:
                                        </p>
                                        <ul>
                                            <li>They don't require manually labeled data</li>
                                            <li>They learn from raw text without external annotations</li>
                                        </ul>
                                        <p>
                                            However, they resemble supervised learning because:
                                        </p>
                                        <ul>
                                            <li>They predict the next token given previous tokens</li>
                                            <li>The target output (next word) is derived from the input data itself</li>
                                            <li>They use a predictive objective function similar to supervised models</li>
                                            <li>This is sometimes called "self-supervised learning"</li>
                                        </ul>
                                    </div>
                                </div>

                                <div className="qa-item" data-qa-id="nlp-10">
                                    <div className={`question ${openQAs['nlp-10'] ? 'open' : ''}`} onClick={() => toggleQA('nlp-10')}>
                                        Softmax issues in language models
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['nlp-10'] ? 'open' : ''}`}>
                                        <p>
                                            Problems with softmax in large vocabulary language models:
                                        </p>
                                        <ul>
                                            <li>Computational expense: Computing softmax over large vocabularies (50K-1M words) is slow</li>
                                            <li>Memory usage: Requires storing and updating large weight matrices</li>
                                            <li>Normalization requires considering all vocabulary items</li>
                                        </ul>
                                        <p>
                                            Solutions include:
                                        </p>
                                        <ul>
                                            <li>Hierarchical softmax: Uses tree structure to reduce complexity</li>
                                            <li>Noise Contrastive Estimation (NCE): Converts problem to binary classification</li>
                                            <li>Negative sampling: Optimizes only for subset of negative examples</li>
                                            <li>Adaptive softmax: Uses clusters of varying sizes for different frequency words</li>
                                            <li>Self-normalization techniques to avoid computing full normalization constant</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Methods - Computer Vision */}
                        <section className={`section ${activeSection === 'ml-cv' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Computer Vision</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Computer vision techniques for processing and understanding visual data. Key areas include
                                    convolutional networks, architectural elements, and optimization techniques for visual processing tasks.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="cv-1">
                                    <div className={`question ${openQAs['cv-1'] ? 'open' : ''}`} onClick={() => toggleQA('cv-1')}>
                                        Filter visualization methods
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-1'] ? 'open' : ''}`}>
                                        <ol>
                                            <li>Direct visualization of learned filters</li>
                                            <li>Activation maximization: Generate images that maximize activations of specific neurons</li>
                                            <li>Gradient ascent to find input patterns that maximize feature map responses</li>
                                            <li>Deconvolution or guided backpropagation to visualize what parts of an image activate specific filters</li>
                                            <li>Feature inversion to reconstruct inputs from feature maps</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-2">
                                    <div className={`question ${openQAs['cv-2'] ? 'open' : ''}`} onClick={() => toggleQA('cv-2')}>
                                        "Locally connected" meaning
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-2'] ? 'open' : ''}`}>
                                        <p>
                                            Convolutional layers are "locally connected" because:
                                        </p>
                                        <ul>
                                            <li>Each neuron connects only to a small region of the input (receptive field)</li>
                                            <li>The same set of weights is applied across different positions (weight sharing)</li>
                                            <li>This contrasts with fully connected layers where each neuron connects to all inputs</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-3">
                                    <div className={`question ${openQAs['cv-3'] ? 'open' : ''}`} onClick={() => toggleQA('cv-3')}>
                                        Zero padding purpose
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-3'] ? 'open' : ''}`}>
                                        <p>
                                            Zero padding serves several purposes:
                                        </p>
                                        <ol>
                                            <li>Preserves spatial dimensions after convolution</li>
                                            <li>Allows for more convolutional layers</li>
                                            <li>Gives equal importance to border pixels</li>
                                            <li>Enables detection of features at image edges</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-4">
                                    <div className={`question ${openQAs['cv-4'] ? 'open' : ''}`} onClick={() => toggleQA('cv-4')}>
                                        1x1 convolutional layer purpose
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-4'] ? 'open' : ''}`}>
                                        <p>
                                            1x1 convolutions serve as:
                                        </p>
                                        <ol>
                                            <li>Dimensionality reduction/expansion in the channel dimension</li>
                                            <li>Adding non-linearity without changing spatial dimensions</li>
                                            <li>Feature recombination across channels</li>
                                            <li>Computationally efficient way to change depth</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-5">
                                    <div className={`question ${openQAs['cv-5'] ? 'open' : ''}`} onClick={() => toggleQA('cv-5')}>
                                        Pooling types and effects
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-5'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Max pooling: Extracts the most prominent features, more common in practice</li>
                                            <li>Average pooling: Smooths features, preserves more background information</li>
                                        </ul>
                                        <p>
                                            Removing pooling entirely increases computation, parameters, and may lead to overfitting, 
                                            but can preserve spatial information.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-6">
                                    <div className={`question ${openQAs['cv-6'] ? 'open' : ''}`} onClick={() => toggleQA('cv-6')}>
                                        Filter size effects
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-6'] ? 'open' : ''}`}>
                                        <p>
                                            Larger filter sizes:
                                        </p>
                                        <ul>
                                            <li>Capture larger receptive field and more global patterns</li>
                                            <li>Increase computational cost (more operations)</li>
                                            <li>Increase number of parameters</li>
                                            <li>May lead to overfitting with limited data</li>
                                        </ul>
                                        <p>
                                            Smaller filter sizes:
                                        </p>
                                        <ul>
                                            <li>Capture more local, fine-grained features</li>
                                            <li>More efficient computation</li>
                                            <li>Fewer parameters</li>
                                            <li>May require more layers to capture global context</li>
                                        </ul>
                                        <p>
                                            Ideal filter size depends on the nature of the visual task, but 3x3 filters are common as they offer good balance.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-7">
                                    <div className={`question ${openQAs['cv-7'] ? 'open' : ''}`} onClick={() => toggleQA('cv-7')}>
                                        Upsampling methods
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-7'] ? 'open' : ''}`}>
                                        <p>
                                            Upsampling is needed for:
                                        </p>
                                        <ul>
                                            <li>Segmentation tasks where pixel-level output is required</li>
                                            <li>Generative models to produce high-resolution outputs</li>
                                            <li>Feature map expansion in encoder-decoder architectures</li>
                                            <li>Super-resolution tasks</li>
                                        </ul>
                                        <p>
                                            Common upsampling methods:
                                        </p>
                                        <ul>
                                            <li>Nearest neighbor: Simple replication of pixels</li>
                                            <li>Bilinear/bicubic interpolation: Weighted average of neighboring pixels</li>
                                            <li>Transposed convolution (deconvolution): Learnable upsampling</li>
                                            <li>Unpooling: Reversing max-pooling operations</li>
                                            <li>Pixel shuffle: Rearranging low-resolution feature maps</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-8">
                                    <div className={`question ${openQAs['cv-8'] ? 'open' : ''}`} onClick={() => toggleQA('cv-8')}>
                                        Depthwise separable convolutions
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-8'] ? 'open' : ''}`}>
                                        <p>
                                            Depthwise separable convolutions reduce parameters by:
                                        </p>
                                        <ol>
                                            <li>Splitting the standard convolution into two separate operations:
                                                <ul>
                                                    <li>Depthwise convolution: Applies a single filter per input channel</li>
                                                    <li>Pointwise convolution: 1x1 convolution to combine outputs</li>
                                                </ul>
                                            </li>
                                        </ol>
                                        <p>
                                            Parameter reduction example:
                                        </p>
                                        <ul>
                                            <li>Regular convolution with 32 input channels, 64 output channels, 3x3 filters: 32 × 64 × 3 × 3 = 18,432 parameters</li>
                                            <li>Depthwise separable:
                                                <ul>
                                                    <li>Depthwise: 32 × 1 × 3 × 3 = 288 parameters</li>
                                                    <li>Pointwise: 32 × 64 × 1 × 1 = 2,048 parameters</li>
                                                    <li>Total: 2,336 parameters (87% reduction)</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-9">
                                    <div className={`question ${openQAs['cv-9'] ? 'open' : ''}`} onClick={() => toggleQA('cv-9')}>
                                        Transfer learning with different image sizes
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-9'] ? 'open' : ''}`}>
                                        <p>
                                            Yes, you can use an ImageNet-trained model on different sized images (320x360) by:
                                        </p>
                                        <ol>
                                            <li>Resizing input images to 256x256 (simplest approach)</li>
                                            <li>Modifying the model architecture:
                                                <ul>
                                                    <li>Fully convolutional networks can handle arbitrary input sizes</li>
                                                    <li>Replace final fully-connected layers with global pooling</li>
                                                    <li>Keep all convolutional layers with their trained weights</li>
                                                </ul>
                                            </li>
                                            <li>Using adaptive pooling layers before any fixed-size layers</li>
                                            <li>Fine-tuning the model on your task-specific data</li>
                                        </ol>
                                        <p>
                                            Note: Input size affects the receptive field and feature map sizes through the network.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="cv-10">
                                    <div className={`question ${openQAs['cv-10'] ? 'open' : ''}`} onClick={() => toggleQA('cv-10')}>
                                        Converting FC layer to convolutional layer
                                        <span className="difficulty hard">Hard</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['cv-10'] ? 'open' : ''}`}>
                                        <p>
                                            A fully-connected layer can be converted to a convolutional layer by:
                                        </p>
                                        <ol>
                                            <li>Reshaping the weight matrix into a set of convolutional filters</li>
                                            <li>For an FC layer connecting an input of size H×W×C to N outputs:
                                                <ul>
                                                    <li>Convert to N filters of size H×W×C with stride=1</li>
                                                    <li>Each filter produces a 1×1 output</li>
                                                    <li>The N outputs are equivalent to the FC outputs</li>
                                                </ul>
                                            </li>
                                        </ol>
                                        <p>
                                            Benefits:
                                        </p>
                                        <ul>
                                            <li>Allows for arbitrary input sizes (fully convolutional network)</li>
                                            <li>Enables dense prediction across spatial dimensions</li>
                                            <li>Useful for tasks like segmentation, detection over sliding windows</li>
                                            <li>Preserves spatial information that would be lost in flattening</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Methods - Reinforcement Learning */}
                        <section className={`section ${activeSection === 'ml-rl' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Reinforcement Learning</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Reinforcement learning approaches for decision-making systems. This includes the exploration-exploitation tradeoff,
                                    discount factors, policy approaches, and model-based vs. model-free methods.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="rl-1">
                                    <div className={`question ${openQAs['rl-1'] ? 'open' : ''}`} onClick={() => toggleQA('rl-1')}>
                                        Explore vs. exploit tradeoff
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['rl-1'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Exploration: Trying new actions to gather information</li>
                                            <li>Exploitation: Using known information to maximize rewards</li>
                                        </ul>
                                        <p>
                                            The tradeoff involves balancing immediate rewards (exploitation) against potential future rewards from 
                                            discovering better strategies (exploration). Examples: multi-armed bandits, epsilon-greedy policies.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="rl-2">
                                    <div className={`question ${openQAs['rl-2'] ? 'open' : ''}`} onClick={() => toggleQA('rl-2')}>
                                        Discount factor purpose
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['rl-2'] ? 'open' : ''}`}>
                                        <p>
                                            The discount factor in RL serves to:
                                        </p>
                                        <ol>
                                            <li>Make future rewards worth less than immediate rewards</li>
                                            <li>Ensure the sum of rewards converges for infinite horizon problems</li>
                                            <li>Model the uncertainty in future rewards</li>
                                            <li>Mathematically guarantee the existence of optimal policies</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="rl-3">
                                    <div className={`question ${openQAs['rl-3'] ? 'open' : ''}`} onClick={() => toggleQA('rl-3')}>
                                        On-policy vs. off-policy
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['rl-3'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>On-policy: Learn about the policy being used for decisions (e.g., SARSA)</li>
                                            <li>Off-policy: Learn about an optimal policy while following a different behavior policy (e.g., Q-learning)</li>
                                        </ul>
                                        <p>
                                            On-policy methods can be more stable but less sample-efficient, while off-policy methods can be 
                                            more sample-efficient but potentially unstable.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="rl-4">
                                    <div className={`question ${openQAs['rl-4'] ? 'open' : ''}`} onClick={() => toggleQA('rl-4')}>
                                        Finite vs. infinite horizon effects
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['rl-4'] ? 'open' : ''}`}>
                                        <p>
                                            The horizon affects RL algorithms in several ways:
                                        </p>
                                        <ul>
                                            <li>Finite horizon: Fixed number of time steps
                                                <ul>
                                                    <li>Optimal policies may be non-stationary (different at each time step)</li>
                                                    <li>Requires backward induction solutions</li>
                                                    <li>No need for discount factor to ensure convergence</li>
                                                </ul>
                                            </li>
                                            <li>Infinite horizon: Continues indefinitely
                                                <ul>
                                                    <li>Optimal policies are typically stationary (same action in same state)</li>
                                                    <li>Requires discount factor (&lt; 1) for convergence</li>
                                                    <li>Can use iterative methods like value/policy iteration</li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="rl-5">
                                    <div className={`question ${openQAs['rl-5'] ? 'open' : ''}`} onClick={() => toggleQA('rl-5')}>
                                        Model-based vs. model-free methods
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['rl-5'] ? 'open' : ''}`}>
                                        <p>
                                            Comparing model-based and model-free approaches:
                                        </p>
                                        <p>
                                            Model-based methods:
                                        </p>
                                        <ul>
                                            <li>Learn/use an explicit model of state transitions and rewards</li>
                                            <li>Can plan ahead using the model (e.g., with dynamic programming)</li>
                                            <li>More data-efficient: can simulate experiences</li>
                                            <li>Examples: PILCO, MBRL, Dyna-Q</li>
                                        </ul>
                                        <p>
                                            Model-free methods:
                                        </p>
                                        <ul>
                                            <li>Learn policies or value functions directly from experience</li>
                                            <li>Don't require a model of the environment</li>
                                            <li>Typically simpler to implement</li>
                                            <li>Can handle complex environments where models are hard to learn</li>
                                            <li>Examples: Q-learning, SARSA, Policy Gradients</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="rl-6">
                                    <div className={`question ${openQAs['rl-6'] ? 'open' : ''}`} onClick={() => toggleQA('rl-6')}>
                                        Policy derivation from reward
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['rl-6'] ? 'open' : ''}`}>
                                        <p>
                                            Given a policy, the reward function can be derived by:
                                        </p>
                                        <ol>
                                            <li>Using Inverse Reinforcement Learning (IRL) to find a reward function that explains the policy</li>
                                            <li>Assuming the policy is optimal, the reward function should make the policy's actions have higher expected values than alternatives</li>
                                            <li>Formulating constraints: V<sup>π</sup>(s) ≥ V<sup>π'</sup>(s) for all alternative policies π'</li>
                                            <li>Finding reward values that satisfy these constraints</li>
                                        </ol>
                                        <p>
                                            This process is called reward function inference and is used in imitation learning and apprenticeship learning.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="rl-7">
                                    <div className={`question ${openQAs['rl-7'] ? 'open' : ''}`} onClick={() => toggleQA('rl-7')}>
                                        Minimax algorithm application
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['rl-7'] ? 'open' : ''}`}>
                                        <p>
                                            The minimax algorithm is used for two-player zero-sum games:
                                        </p>
                                        <ul>
                                            <li>MAX player aims to maximize the score/utility</li>
                                            <li>MIN player aims to minimize the score/utility</li>
                                            <li>Algorithm alternates between MAX and MIN moves down the game tree</li>
                                            <li>At MAX nodes, choose the move with maximum value</li>
                                            <li>At MIN nodes, choose the move with minimum value</li>
                                            <li>Values are propagated up from terminal states (or evaluation functions)</li>
                                        </ul>
                                        <p>
                                            This guarantees optimal play against a perfect opponent and is commonly used in games like chess, checkers, and tic-tac-toe.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        {/* ML Methods - Training Neural Networks */}
                        <section className={`section ${activeSection === 'ml-training' ? 'active' : ''}`}>
                            <div className="section-header">
                                <h2>Training Neural Networks</h2>
                            </div>
                            
                            <div className="summary-box">
                                <div className="summary-title">Summary</div>
                                <p>
                                    Techniques and considerations for effectively training neural network models. This includes
                                    training approaches, activation functions, architectural choices, optimization techniques,
                                    hyperparameter selection, and model development practices.
                                </p>
                            </div>
                            
                            <div className="qa-list">
                                <div className="qa-item" data-qa-id="train-1">
                                    <div className={`question ${openQAs['train-1'] ? 'open' : ''}`} onClick={() => toggleQA('train-1')}>
                                        Overfit vs. underfit priority
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-1'] ? 'open' : ''}`}>
                                        <p>
                                            Generally, you should aim to overfit first:
                                        </p>
                                        <ol>
                                            <li>Ensure model has enough capacity to learn the problem</li>
                                            <li>Verify that the optimization process works</li>
                                            <li>Then apply regularization to address overfitting</li>
                                        </ol>
                                        <p>
                                            It's easier to diagnose and fix overfitting than underfitting.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-2">
                                    <div className={`question ${openQAs['train-2'] ? 'open' : ''}`} onClick={() => toggleQA('train-2')}>
                                        Activation functions comparison
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-2'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Sigmoid: Outputs between 0-1, useful for probabilities, but suffers from vanishing gradients</li>
                                            <li>Tanh: Similar to sigmoid but outputs between -1 to 1, zero-centered</li>
                                            <li>ReLU: f(x) = max(0,x), computationally efficient, but can cause "dead neurons"</li>
                                            <li>Leaky ReLU: Allows small negative values to address the dying ReLU problem</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-3">
                                    <div className={`question ${openQAs['train-3'] ? 'open' : ''}`} onClick={() => toggleQA('train-3')}>
                                        Skip connection motivation
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-3'] ? 'open' : ''}`}>
                                        <p>
                                            Skip connections (residual connections):
                                        </p>
                                        <ol>
                                            <li>Help mitigate vanishing gradients by providing direct paths for gradient flow</li>
                                            <li>Enable training of much deeper networks</li>
                                            <li>Allow networks to learn identity functions easily</li>
                                            <li>Improve information flow through the network</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-4">
                                    <div className={`question ${openQAs['train-4'] ? 'open' : ''}`} onClick={() => toggleQA('train-4')}>
                                        Vanishing/exploding gradients
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-4'] ? 'open' : ''}`}>
                                        <ul>
                                            <li>Vanishing: Gradients become extremely small, preventing effective learning in earlier layers</li>
                                            <li>Exploding: Gradients become extremely large, causing unstable updates</li>
                                        </ul>
                                        <p>
                                            RNNs are especially susceptible because the same weights are applied repeatedly across time steps, 
                                            causing multiplicative effects.
                                        </p>
                                        <p>
                                            Solutions for exploding gradients include:
                                        </p>
                                        <ul>
                                            <li>Gradient clipping</li>
                                            <li>Weight regularization</li>
                                            <li>Proper weight initialization</li>
                                            <li>Batch normalization</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-5">
                                    <div className={`question ${openQAs['train-5'] ? 'open' : ''}`} onClick={() => toggleQA('train-5')}>
                                        ReLU differentiability
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-5'] ? 'open' : ''}`}>
                                        <p>
                                            ReLU is not differentiable at x = 0, but this isn't a practical issue because:
                                        </p>
                                        <ul>
                                            <li>The probability of landing exactly at x = 0 is negligible</li>
                                            <li>We can define a sub-gradient at x = 0 (typically set to 0 or 0.5)</li>
                                            <li>Modern frameworks handle this case automatically</li>
                                        </ul>
                                        <p>
                                            ReLU&apos;s derivative is 1 for x &gt; 0 and 0 for x &lt; 0, making it computationally efficient.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-6">
                                    <div className={`question ${openQAs['train-6'] ? 'open' : ''}`} onClick={() => toggleQA('train-6')}>
                                        Batch normalization vs. layer normalization
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-6'] ? 'open' : ''}`}>
                                        <p>
                                            Batch Normalization:
                                        </p>
                                        <ul>
                                            <li>Normalizes across the batch dimension for each feature</li>
                                            <li>Dependent on batch size (performs poorly with small batches)</li>
                                            <li>Introduces batch-dependent noise (can act as regularization)</li>
                                            <li>Requires different handling during training and inference</li>
                                            <li>Common in CNNs</li>
                                        </ul>
                                        <p>
                                            Layer Normalization:
                                        </p>
                                        <ul>
                                            <li>Normalizes across all features for each example in the batch</li>
                                            <li>Independent of batch size</li>
                                            <li>Same behavior during training and inference</li>
                                            <li>Common in RNNs and Transformers</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-7">
                                    <div className={`question ${openQAs['train-7'] ? 'open' : ''}`} onClick={() => toggleQA('train-7')}>
                                        Adam vs SGD comparison
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-7'] ? 'open' : ''}`}>
                                        <p>
                                            Adam:
                                        </p>
                                        <ul>
                                            <li>Faster convergence, especially early in training</li>
                                            <li>Adaptive learning rates per parameter</li>
                                            <li>Less sensitive to hyperparameter choices</li>
                                            <li>Includes momentum and RMSprop-like components</li>
                                            <li>May generalize slightly worse than SGD with momentum in some cases</li>
                                        </ul>
                                        <p>
                                            SGD (with momentum):
                                        </p>
                                        <ul>
                                            <li>Often achieves better final generalization</li>
                                            <li>Requires more careful learning rate scheduling</li>
                                            <li>Can escape sharp minima better (leading to more robust solutions)</li>
                                            <li>More stable training in the later stages</li>
                                        </ul>
                                        <p>
                                            Common practice: Start with Adam for fast initial convergence, then switch to SGD for fine-tuning.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-8">
                                    <div className={`question ${openQAs['train-8'] ? 'open' : ''}`} onClick={() => toggleQA('train-8')}>
                                        Two consecutive linear layers issue
                                        <span className="difficulty medium">Medium</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-8'] ? 'open' : ''}`}>
                                        <p>
                                            Having two consecutive linear layers without a non-linearity in between is inefficient because:
                                        </p>
                                        <ul>
                                            <li>The composition of two linear transformations is equivalent to a single linear transformation</li>
                                            <li>If y = W₂(W₁x + b₁) + b₂, this can be rewritten as y = (W₂W₁)x + (W₂b₁ + b₂)</li>
                                            <li>This introduces redundant parameters without adding modeling capacity</li>
                                            <li>Non-linearities between layers are what allow neural networks to represent complex functions</li>
                                        </ul>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-9">
                                    <div className={`question ${openQAs['train-9'] ? 'open' : ''}`} onClick={() => toggleQA('train-9')}>
                                        Weight initialization importance
                                        <span className="difficulty easy">Easy</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-9'] ? 'open' : ''}`}>
                                        <p>
                                            We don't initialize all weights to zero because:
                                        </p>
                                        <ul>
                                            <li>Symmetry problem: All neurons in a layer would compute the same output</li>
                                            <li>All neurons would receive the same gradient and update identically</li>
                                            <li>The network can't learn different features in each neuron</li>
                                            <li>Network would effectively have much less capacity than intended</li>
                                        </ul>
                                        <p>
                                            Proper initialization methods (Xavier/Glorot, He, etc.) break symmetry while maintaining appropriate scale of activations and gradients.
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="qa-item" data-qa-id="train-10">
                                    <div className={`question ${openQAs['train-10'] ? 'open' : ''}`} onClick={() => toggleQA('train-10')}>
                                        Knowledge distillation purpose
                                        <span className="difficulty hard">Hard</span>
                                        <i className="fas fa-chevron-down"></i>
                                    </div>
                                    <div className={`answer ${openQAs['train-10'] ? 'open' : ''}`}>
                                        <p>
                                            We use knowledge distillation instead of training small models directly because:
                                        </p>
                                        <ul>
                                            <li>Large models learn better representations from the data</li>
                                            <li>These models capture useful information beyond just class labels (soft targets)</li>
                                            <li>Distillation transfers this additional information to the smaller model</li>
                                            <li>Soft targets provide richer training signal than hard labels</li>
                                            <li>Small models trained with distillation often outperform those trained directly on raw data</li>
                                            <li>The teacher model provides a form of regularization, helping the student model generalize better</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>